#include <stdio.h>
#include <assert.h>
#include <vector>
#include <fstream>
#include <iostream>
#include <cstdio>
#include <ctime>
#include <map>

#include "quadEdge.h"
#include "site.h"
#include "delaunay.h"
#include "traverse.h"

// TODO
// assignment and comparison between sites and quadEdges
// the constructor and destructor
// output

using namespace std;

void DelaunayTest(void)
{
	std::vector<site*> sites;
	sites.push_back(new site(1, 0.0f, 0.0f));
	sites.push_back(new site(2, 1.0f, 1.0f));
	sites.push_back(new site(3, 2.0f, 0.0f));
	sites.push_back(new site(4, 3.0f, 1.0f));

	delaunay delaunaytr(sites);
	vector<bool> traversed;
	for (int i = 0; i < 4; ++i)
	{
		traversed.push_back(0);
	}

	string file_name = "./output.ele";
	ofstream output(file_name);
	quadEdge* startLedge = delaunaytr.le;
	traverse edgeTraversal(startLedge, output);
	output << "# Generated by " << endl;
	output.close();
	map<quadEdge*, bool> edges = edgeTraversal.pastEdgeDict;
	
	// const char* num_triangle = to_string(edgeTraversal.getNumtri());
	// cout << num_triangle << endl;
	// FILE * pFile;
	// pFile = fopen("./output.ele", "r+");
	// fseek(pFile, 0, SEEK_SET);
	// fputs(num_triangle, pFile);
	// fclose(pFile);
}

void DelaunayTest(vector<site*> sites)
{
	delaunay delaunaytr(sites);
	vector<bool> traversed;
	for (int i = 0; i < 4; ++i)
	{
		traversed.push_back(0);
	}

	string file_name = "./output.ele";
	ofstream output(file_name);
	quadEdge* startLedge = delaunaytr.le;
	traverse edgeTraversal(startLedge, output);
	output << "# Generated by " << endl;
	output.close();
	map<quadEdge*, bool> edges = edgeTraversal.pastEdgeDict;
	
	// const char* num_triangle = to_string(edgeTraversal.getNumtri());
	// cout << num_triangle << endl;
	// FILE * pFile;
	// pFile = fopen("./output.ele", "r+");
	// fseek(pFile, 0, SEEK_SET);
	// fputs(num_triangle, pFile);
	// fclose(pFile);
}

int main(int argc, char** argv)
{
	// DelaunayTest();

	ifstream infile(argv[1]);
	int num_v, num_dim, num_attr, boundary_marker;
	infile >> num_v >> num_dim >> num_attr >> boundary_marker;

	if (num_v <=0 ){
		cout << "No points to process\n" << endl;
		return 0;
	}
	else{
		printf(" Reading file %s, in total %d vertices to process\n", argv[1], num_v);
	}

	vector<site*> sites;
	int vid;
	float p1, p2;
	for (int i = 0; i < num_v; ++i)
	{
		infile >> vid >> p1 >> p2;
		sites.push_back(new site(vid, p1, p2));
	}

	// use std::sort, with self-defined sorting scheme
	sort(sites.begin(), sites.end(), siteLessPredicate);

	// test sorting
	ofstream mysort;
	mysort.open ("testsort.txt");
	for (int i = 0; i < num_v; ++i)
	{
		mysort << sites[i]->index << " " << sites[i]->vx << " " << sites[i]->vy <<"\n";
	}
	mysort.close();
	cout << "Finish testing sort" << endl;

	clock_t start = clock();
	DelaunayTest(sites);
	
	delaunay delaunaytr(sites);
	double duration = ( clock() - start ) / (double) CLOCKS_PER_SEC;
    cout<<"Delaunay Triangulation takes (in s): "<< duration <<'\n';

	//
	vector<site*>::iterator site_s = sites.begin();
	vector<site*>::iterator site_e = sites.end();
	while (site_s != site_e)
	{
		delete *site_s;
		site_s++;
	}

	return 0;
}