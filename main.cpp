//#include <stdio.h>
#include <assert.h>
#include <string>
#include <vector>
#include <fstream>
#include <iostream>
#include <cstdio>
//#include <cstring>
#include <ctime>
#include <map>
#include <iomanip>

#include "quadEdge.h"
#include "site.h"
#include "delaunay.h"
#include "traverse.h"

// TODO
// assignment and comparison between sites and quadEdges
// the constructor and destructor
// output

using namespace std;

void dtTest(void)
{
	vector<site*> sites;
	sites.push_back(new site(1, 0.0f, 0.0f));
	sites.push_back(new site(2, 1.0f, 1.0f));
	sites.push_back(new site(3, 2.0f, 0.0f));
	sites.push_back(new site(4, 3.0f, 1.0f));

	delaunay delaunaytr(sites);
	vector<bool> traversed;
	for (int i = 0; i < 4; ++i)
	{
		traversed.push_back(0);
	}

	string file_name = "./output.ele";
	ofstream output(file_name);
	quadEdge* startLedge = delaunaytr.le;
	traverse edgeTraversal(startLedge, output);
	output << "# Generated by " << endl;
	output.close();
	map<quadEdge*, bool> edges = edgeTraversal.pastEdgeDict;
}

void dtTest(vector<site*> sites, char * filename)
{
	delaunay delaunaytr(sites);
	vector<bool> traversed;
	for (int i = 0; i < 4; ++i)
	{
		traversed.push_back(0);
	}

	string file_name = strcat(filename, ".ele");
	ofstream output(file_name);
	quadEdge* startLedge = delaunaytr.le;
	traverse edgeTraversal(startLedge, output);
	output << "# Generated by " << endl;
	output.close();
	map<quadEdge*, bool> edges = edgeTraversal.pastEdgeDict;
	
	int num_triangle = edgeTraversal.getNumtri();
	printf("DT gnerated %2d triangles.\n", num_triangle);

	FILE * pFile;
	pFile = fopen(file_name.c_str(), "w+");
	char stream_char[10];
	sprintf(stream_char, "%10d", num_triangle);
	cout << "stream_char:" <<stream_char << endl;
	fseek ( pFile , 0, SEEK_SET );
	fputs(stream_char, pFile);

	/*
	ostream num_triangle_stream;
	num_triangle_stream << setw(10) << num_triangle << endl;
	num_triangle_stream.write(&stream_char, 10);
	fputs(num_triangle_stream, pFile);	
	*/
	fclose(pFile);
}

int main(int argc, char** argv)
{
	ifstream infile(argv[1]);
	int num_v, num_dim, num_attr, boundary_marker;
	infile >> num_v >> num_dim >> num_attr >> boundary_marker;
	// const string inputnodefile, outelefile;
	// inputnodefile = argv[1];
	// outelefile =  argv[1];
	strcat(argv[1], ".node");

	if (num_v <=0 ){
		cout << "No points to process\n" << endl;
		return 0;
	}
	else{
		printf("Reading file %s, in total %d vertices to process\n", argv[1], num_v);
	}

	vector<site*> sites;
	int vid;
	float p1, p2;
	for (int i = 0; i < num_v; ++i)
	{
		infile >> vid >> p1 >> p2;
		sites.push_back(new site(vid, p1, p2));
	}

	// use std::sort, with self-defined sorting scheme
	sort(sites.begin(), sites.end(), siteLessPredicate);

	clock_t start = clock();
	dtTest(sites, argv[1]);
	
	delaunay delaunaytr(sites);
	double duration = ( clock() - start ) / (double) CLOCKS_PER_SEC;
    cout<<"Delaunay Triangulation takes (in s): "<< duration <<'\n';
    
	//
	vector<site*>::iterator site_s = sites.begin();
	vector<site*>::iterator site_e = sites.end();
	while (site_s != site_e)
	{
		delete *site_s;
		site_s++;
	}

	return 0;
}